# -*- snakemake -*-

import yaml
import itertools
import pandas

sampletable = pandas.read_table(config['sampletable'], index_col=0)
samples = sampletable.index.tolist()


def fastq_screen_config_inputs():
    """
    Returns indexes and a table (as string) that can be written directly to
    a config file.

    Use indexes as the input to a rule; use the table to build a config file.
    """
    indexes = config['rules']['fastq_screen']['indexes']
    aligner = config['rules']['fastq_screen']['aligner']
    inputs = []
    for label, prefix in indexes.items():
        prefix = os.path.join(config['data_dir'], prefix)
        inputs.extend(expand(prefix + '.{n}.bt2', n=[1, 2, 3, 4]))
    return inputs


patterns = [
    '{sample_dir}/{sample}/{sample}_R1.fastqc.html',
    '{sample_dir}/{sample}/{sample}_R1.fastq_screen.txt',
    '{sample_dir}/{sample}/{sample}_R1.fastq_screen.png',
    '{sample_dir}/{sample}/{sample}_R1.cutadapt.fastqc.html',
    '{sample_dir}/{sample}/{sample}_R1.cutadapt.fastq.gz',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.bam',
    '{sample_dir}/{sample}/{sample}.cutadapt.bt2.bam',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.observed_complexity',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.estimated_complexity',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.estimated_coverage',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.bam',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.metrics',
    'multiqc_report.html',
    'fastq_screen_config.txt',

]
supplied = {'sample': samples, 'sample_dir': config['sample_dir']}

# Fill in each pattern with each item in "supplied", resulting in a list of
# lists. Collapse that into a list of strings, and then unique them into a set
# since e.g. expand('a', samples=[1, 2, 3, 4]) results in ['a', 'a', 'a', 'a']
targets = list(
    set(
        itertools.chain(
            *map(lambda x: expand(x, **supplied), patterns)
        )
    )
)


# srcdir() is a snakemake built-in function. WRAPPERS must be relative to this
# file.
HERE = srcdir('')
WRAPPERS = '../../wrappers'


include: '../references/references.snakefile'

def wrapper_for(tool):
    """
    Returns the wrapper directory for the specified tool
    """
    return os.path.join(HERE, WRAPPERS, tool)


def params_for(rule, key):
    d = config.get('rules', {}).get(rule, {}).get('params', {}).get(key, '')
    return d


def threads_for(rule):
    return config.get('rules', {}).get(rule, {}).get('threads', {})

rule all:
    input: targets


rule clean:
    run:
        shell('rm -r {config[sample_dir]}')
        shell('./get-data.sh')


rule fastqc:
    input: 'pasilla/{sample}/{sample}{suffix}.fastq.gz'
    output:
        html='pasilla/{sample}/{sample}{suffix}.fastqc.html',
        zip='pasilla/{sample}/{sample}{suffix}_fastqc.zip',
    params: extra=params_for('fastqc', 'extra')
    wrapper:
        wrapper_for('fastqc')


rule cutadapt:
    input: 'pasilla/{sample}/{sample}_R1.fastq.gz'
    output: 'pasilla/{sample}/{sample}_R1.cutadapt.fastq.gz'
    log: 'pasilla/{sample}/{sample}_R1.cutadapt.fastq.log'
    params: extra=params_for('cutadapt', 'extra')
    wrapper:
        wrapper_for('cutadapt')


def multiqc_inputs():
    inputs = []
    check_for = ['fastq', 'bam']
    for i in targets:
        for j in check_for:
            if j in i:
                # Doesn't matter which of `check_for` we found, just *that* we
                # found one, so we only add the input once.
                inputs.append(i)
                break
    return inputs


rule multiqc:
    input: multiqc_inputs()
    output: 'multiqc_report.html'
    log: 'multiqc_report.log'
    params: analysis_directory=config['sample_dir']
    wrapper:
        wrapper_for('multiqc')


rule hisat2:
    input:
        fastq='{sample_dir}/{sample}/{sample}_R1.cutadapt.fastq.gz',
        index=expand('{data_dir}/{assembly}/hisat2/dm6_default.{n}.ht2',
                     data_dir=config['data_dir'],
                     assembly=config['assembly'],
                     n=range(1, 9)),
    output:
        '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.bam'
    log: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.bam.log'
    params: extra=params_for('hisat2', 'extra')
    threads: threads_for('hisat2')
    wrapper:
        wrapper_for('hisat2')


rule fastq_screen_config_file:
    input: fastq_screen_config_inputs()
    output: 'fastq_screen_config.txt'
    run:
        indexes = config['rules']['fastq_screen']['indexes']
        aligner = config['rules']['fastq_screen']['aligner']
        inputs = []
        table = []
        for label, prefix in indexes.items():
            prefix = os.path.join(config['data_dir'], prefix)
            table.append(['DATABASE', label, prefix, aligner.upper()])

        table = fastq_screen_config_inputs()[1]
        with open(output[0], 'w') as fout:
            fout.write(table)


rule fastq_screen:
    input:
        '{sample_dir}/{sample}/{sample}_R1.fastq.gz',
        'fastq_screen_config.txt'
    output:
        txt='{sample_dir}/{sample}/{sample}_R1.fastq_screen.txt',
        png='{sample_dir}/{sample}/{sample}_R1.fastq_screen.png'
    log: '{sample_dir}/{sample}/{sample}_R1.fastq_screen.log'
    params: fastq_screen_config='fastq_screen_config.txt'
    wrapper:
        wrapper_for('fastq_screen')


rule samtools_unique:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam'
    wrapper:
        wrapper_for('samtools/view')


rule samtools_sort:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam'
    wrapper:
        wrapper_for('samtools/sort')


rule samtools_index:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam.bai'
    wrapper:
        wrapper_for('samtools/index')


rule preseq_observed_complexity:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.observed_complexity'
    wrapper:
        wrapper_for('preseq/observed_complexity')


rule preseq_expected_complexity:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.estimated_complexity'
    wrapper:
        wrapper_for('preseq/estimated_complexity')


rule preseq_expected_coverage:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.estimated_coverage'
    wrapper:
        wrapper_for('preseq/estimated_coverage')


rule bowtie2:
    input: fastq='{sample_dir}/{sample}/{sample}_R1.cutadapt.fastq.gz',
           index=expand('{data_dir}/{assembly}/bowtie2/dm6_default.{n}.bt2',
                        data_dir=config['data_dir'],
                        assembly=config['assembly'],
                        n=range(1,5))
    output:
        '{sample_dir}/{sample}/{sample}.cutadapt.bt2.bam'
    log: '{sample_dir}/{sample}/{sample}.cutadapt.bt2.log'
    wrapper:
        wrapper_for('bowtie2/align')


rule picard_MarkDuplicates:
    input:
        bam = '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam',
        bai = '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam.bai'
    output:
        bam = '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.bam',
        metrics = '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.metrics'
    params: extra=params_for('picard_MarkDuplicates', 'extra')
    log: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.log',
    wrapper:
        wrapper_for('picard/MarkDuplicates')

# vim: ft=python
