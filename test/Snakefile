# -*- snakemake -*-

import yaml
import itertools
import pandas

sampletable = pandas.read_table(config['sampletable'], index_col=0)
samples = sampletable.index.tolist()

patterns = [
    '{sample_dir}/{sample}/{sample}_R1.fastqc.html',
    '{sample_dir}/{sample}/{sample}_R1.fastq_screen.txt',
    '{sample_dir}/{sample}/{sample}_R1.fastq_screen.png',
    '{sample_dir}/{sample}/{sample}_R1.cutadapt.fastqc.html',
    '{sample_dir}/{sample}/{sample}_R1.cutadapt.fastq.gz',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.bam',
    '{sample_dir}/{sample}/{sample}.cutadapt.bt2.bam',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.observed_complexity',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.estimated_complexity',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.estimated_coverage',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.bam',
    '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.metrics',\
    '{sample_dir}/{sample}/{sample}_dupRadar_drescatter.png',
    'bowtie2/dm6_chr2L.1.bt2',
    'multiqc_report.html',
]
supplied = {'sample': samples, 'sample_dir': config['sample_dir']}

# Fill in each pattern with each item in "supplied", resulting in a list of
# lists. Collapse that into a list of strings, and then unique them into a set
# since e.g. expand('a', samples=[1, 2, 3, 4]) results in ['a', 'a', 'a', 'a']
targets = list(
    set(
        itertools.chain(
            *map(lambda x: expand(x, **supplied), patterns)
        )
    )
)

HERE = srcdir('')

# relative to the directory of the current snakefile.
WRAPPERS = '../wrappers'


def wrapper_for(tool):
    """
    Returns the wrapper directory for the specified tool
    """
    return os.path.join(HERE, WRAPPERS, tool)


rule all:
    input: targets

rule clean:
    run:
        for t in targets:
            if os.path.exists(t):
                shell("rm -r {t}")


rule fastqc:
    input: 'pasilla/{sample}/{sample}{suffix}.fastq.gz'
    output:
        html='pasilla/{sample}/{sample}{suffix}.fastqc.html',
        zip='pasilla/{sample}/{sample}{suffix}_fastqc.zip',
    wrapper:
        wrapper_for('fastqc')


rule cutadapt:
    input: 'pasilla/{sample}/{sample}_R1.fastq.gz'
    output: 'pasilla/{sample}/{sample}_R1.cutadapt.fastq.gz'
    log: 'pasilla/{sample}/{sample}_R1.cutadapt.fastq.log'
    params:
        extra=(
            "-a file:adapters.fa "
            "--quality-cutoff 20 "
            "--minimum-length 25 "
            "--overlap 10 ")
    wrapper:
        wrapper_for('cutadapt')


def multiqc_inputs():
    inputs = []
    check_for = ['fastq', 'bam']
    for i in targets:
        for j in check_for:
            if j in i:
                inputs.append(i)
                break
    return inputs


rule multiqc:
    input: multiqc_inputs()
    output: 'multiqc_report.html'
    log: 'multiqc_report.log'
    params: analysis_directory='pasilla'
    wrapper:
        wrapper_for('multiqc')


rule hisat2:
    input:
        fastq='{sample_dir}/{sample}/{sample}_R1.cutadapt.fastq.gz',
        index=expand('{data_dir}/{assembly}/hisat2/dm6_default.{n}.ht2',
                     data_dir=config['data_dir'],
                     assembly=config['assembly'],
                     n=range(1, 9)),
    output:
        '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.bam'
    log: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.bam.log'
    params: extra="--max-intronlen 50000"
    threads: 8
    wrapper:
        wrapper_for('hisat2')


rule fastq_screen:
    input: '{sample_dir}/{sample}/{sample}_R1.fastq.gz'
    output:
        txt='{sample_dir}/{sample}/{sample}_R1.fastq_screen.txt',
        png='{sample_dir}/{sample}/{sample}_R1.fastq_screen.png'
    log: '{sample_dir}/{sample}/{sample}_R1.fastq_screen.log'
    params:
        fastq_screen_config={
            'database': {
                'ecoli': {
                    'bowtie2': '/data/LCDB/references/ecoli/bowtie2/ecoli_default',
                },
                'wolbachia': {
                    'bowtie2': '/data/LCDB/references/wolbachia/bowtie2/wolbachia_default',
                },
                'dm6': {
                    'bowtie2': '/data/LCDB/references/dm6/bowtie2/dm6_default',
                },
            },
            'aligner_paths': {'bowtie2': 'bowtie2'},
        }
    wrapper:
        wrapper_for('fastq_screen')


# TODO: placeholder for samtools view -b -q 20 {input} > {output} rule to
# remove multimappers
rule samtools_unique:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam'
    wrapper:
        wrapper_for('samtools/view')

rule samtools_sort:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam'
    params: ""
    threads: 8
    wrapper:
        wrapper_for('samtools/sort')
        
rule samtools_index:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam.bai'
    params: ""
    wrapper:
        wrapper_for('samtools/index')

rule preseq_observed_complexity:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.observed_complexity'
    wrapper:
        wrapper_for('preseq/observed_complexity')

rule preseq_expected_complexity:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.estimated_complexity'
    wrapper:
        wrapper_for('preseq/estimated_complexity')

rule preseq_expected_coverage:
    input: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam'
    output: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.bam.estimated_coverage'
    wrapper:
        wrapper_for('preseq/estimated_coverage')

rule bowtie2:
    input: fastq='{sample_dir}/{sample}/{sample}_R1.cutadapt.fastq.gz',
           index=expand('{data_dir}/{assembly}/bowtie2/dm6_default.{n}.bt2',
                        data_dir=config['data_dir'],
                        assembly=config['assembly'],
                        n=range(1,5))
    output: 
        '{sample_dir}/{sample}/{sample}.cutadapt.bt2.bam'
    log: '{sample_dir}/{sample}/{sample}.cutadapt.bt2.log'
    wrapper:
        wrapper_for('bowtie2/align')
        
rule bowtie2build:
    input: '{prefix}.fasta'
    output: '{path}/{prefix}.1.bt2'
    log: '{path}/{prefix}.bt2.build.log'
    wrapper:
        wrapper_for('bowtie2/build')

rule picard_MarkDuplicates:
    input:
        bam = '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam',
        bai = '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.bam.bai'
    output:
        bam = '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.bam',
        metrics = '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.metrics'
    params:
        extra="REMOVE_DUPLICATES=false VALIDATION_STRINGENCY=SILENT"
    log: '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.log',
    wrapper:
        wrapper_for('picard/MarkDuplicates')

rule dupRadar:
    input:
       dupBAM = '{sample_dir}/{sample}/{sample}.cutadapt.hisat2.unique.sort.dedup.bam',
       GTF = '/data/LCDB/references/dm6/dm6_r6-11.gtf',
       dupRScript = wrapper_for('dupRadar/dupRadar.R')
    output:
        dupSmooth = '{sample_dir}/{sample}/{sample}_dupRadar_drescatter.png'
    params:
        paired="FALSE",
        stranded="no",
        outdir='{sample_dir}/{sample}'
    threads: 8
    wrapper:
        wrapper_for('dupRadar')
        
# vim: ft=python
